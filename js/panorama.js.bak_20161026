/*panorma web static*/
var camera, scene, renderer;
var container;

var isUserInteracting = false,
    onMouseDownMouseX = 0, onMouseDownMouseY = 0,
    lon = 0, onMouseDownLon = 0,
    lat = 0, onMouseDownLat = 0,
    phi = 0, theta = 0;
var lat_off = 0, lon_off = 0, rot_off = 0;

thheight=500;
var mesh, mesh2;
var material_file;
var current=0;
var current_tramo=0;
function set_material2(file){
  mesh.material.map.dispose();
  mesh.material.dispose();
  var material = new THREE.MeshBasicMaterial( {
    map: THREE.ImageUtils.loadTexture( file )
  } );
  mesh.material = material;
  material_file = file;
  current = parseInt(material_file.substr(material_file.length - 8, 4 ));
}
function update_panorma(feature){
//fixme panfold esta definida en mapa.js viene de cuando se pulsa un tramo
  set_material(panfold+feature.get('file'),
              feature.get('tramo'),feature.get('id'));
  var desc_tramo = getTramoInfoByCoords();
  $("#panorama_title").html(desc_tramo);
  rotate_sphere(feature.get('rot'), feature.get('elev') ,feature.get('azim'));
  if ($("#pano_rot").length ) {
    $("#pano_rot").val(feature.get('rot'));
    $("#pano_elev").val(feature.get('elev'));
    $("#pano_azim").val(feature.get('azim'));
   console.log("id:" + feature.get('id') + 
              " r e a: " + feature.get('rot') +" "+ 
                          feature.get('elev') +" "+ 
                          feature.get('azim')); 
  }
}
function set_material (file,tramo_id,pano_id){

  // instantiate a loader
  var loader = new THREE.TextureLoader();

  // load a resource
  loader.load(
    // resource URL
    "clicnfish/" + file,
    // Function when resource is loaded
    function ( texture ) {
      mesh.material.map.dispose();
      mesh.material.dispose();
      // do something with the texture
      var material = new THREE.MeshBasicMaterial( {
        map: texture
      } );
      mesh.material = material;
      material_file = file;
      current = pano_id;//parseInt(material_file.substr(material_file.length - 8, 4 ));
      current_tramo=tramo_id;
    },
    // Function called when download progresses
    function ( xhr ) {
      //console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
    },
    // Function called when download errors
    function ( xhr ) {
      console.log( 'An error happened' );
    }
  );
}

function rotate_sphere(rot, lat, lon){
  mesh.rotateY(THREE.Math.degToRad(-lon_off));
  mesh.rotateZ(THREE.Math.degToRad(-lat_off));
  mesh.rotateX(THREE.Math.degToRad(-rot_off));
  rot_off = rot;
  lat_off = lat;
  lon_off = lon;
  mesh.rotateX(THREE.Math.degToRad(rot_off));
  mesh.rotateZ(THREE.Math.degToRad(lat_off));
  mesh.rotateY(THREE.Math.degToRad(lon_off));
}

function init(init_file,init_tramo, init_current) {

  container = document.getElementById( 'panorama' );

  camera = new THREE.PerspectiveCamera( 75, container.clientWidth / thheight, 1, 1100 );
  camera.target = new THREE.Vector3( 0, 0, 0 );

  scene = new THREE.Scene();

  var geometry = new THREE.SphereGeometry( 500, 60, 40 );
  geometry.scale( - 1, 1, 1 );
  material_file=init_file;
  current=init_current;
  current_tramo=init_tramo;

  var material = new THREE.MeshBasicMaterial( {
    map: THREE.ImageUtils.loadTexture( material_file )
  } );

  mesh = new THREE.Mesh( geometry, material );

  scene.add( mesh );

  var feature = gotoFeature(current_tramo,current);
  if (feature){
    update_panorma(feature);
  }
  //rotate_sphere(offsets[0],offsets[1],offsets[2]);
  // White directional light at half intensity shining from the top.

  var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
  directionalLight.position.set( 0, 1, 0 );
  scene.add( directionalLight );

  var materialarrow = new THREE.MeshBasicMaterial( {
    map: THREE.ImageUtils.loadTexture( 'img/arrow.png' ),transparent: true,color: 0xffffff
    //map: THREE.ImageUtils.loadTexture( 'data/s-velilla_08.jpg' )
    //map: THREE.ImageUtils.loadTexture( 'data/2294472375_24a3b8ef46_o.jpg' )
  } );
  plane = new THREE.Mesh( new THREE.PlaneGeometry( 50, 50), materialarrow );
  plane.material.side = THREE.DoubleSide;

  plane.rotateX(-3.14149/2);
  plane.position.set( -100, -40, 0 );
  scene.add(plane);

  plane2 = new THREE.Mesh( new THREE.PlaneGeometry( 50, 50), materialarrow );
  plane2.material.side = THREE.DoubleSide;
  plane2.rotateX(-3.14149/2);
  plane2.rotateY(3.14149);
  plane2.position.set( 100, -40, 0 );
  scene.add(plane2);

  var materialcircle = new THREE.MeshBasicMaterial( {
    map: THREE.ImageUtils.loadTexture( 'img/circle2.png' ),transparent: true,color: 0xffffff
  } );

  circle = new THREE.Mesh( new THREE.PlaneGeometry( 60, 60), materialcircle );
  circle.material.side = THREE.DoubleSide;
  circle.rotateX(-3.14149/2);
  circle.position.set( 0, -40, 0 );
  scene.add(circle);

  renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize(container.clientWidth, thheight );
  container.appendChild( renderer.domElement );

  container.addEventListener( 'mousedown', onDocumentMouseDown, false );
  container.addEventListener( 'mousemove', onDocumentMouseMove, false );
  container.addEventListener( 'mouseup', onDocumentMouseUp, false );
  //document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
  container.addEventListener( 'MozMousePixelScroll', onDocumentMouseWheel, false);

  container.addEventListener("touchstart", ontouchstart, false);
  container.addEventListener("touchend", ontouchend, false);
  container.addEventListener("touchmove",ontouchmove, false);
  container.addEventListener("touchcancel", ontouchend, false);

  //
/*
  container.addEventListener( 'dragover', function ( event ) {

    event.preventDefault();
    event.dataTransfer.dropEffect = 'copy';

  }, false );

  container.addEventListener( 'dragenter', function ( event ) {

    document.body.style.opacity = 0.5;

  }, false );

  container.addEventListener( 'dragleave', function ( event ) {

    document.body.style.opacity = 1;

  }, false );

  container.addEventListener( 'drop', function ( event ) {

    event.preventDefault();

    var reader = new FileReader();
    reader.addEventListener( 'load', function ( event ) {

      material.map.image.src = event.target.result;
      material.map.needsUpdate = true;

    }, false );
    reader.readAsDataURL( event.dataTransfer.files[ 0 ] );

    document.body.style.opacity = 1;

  }, false );
*/
  //

  window.addEventListener( 'resize', onWindowResize, false );

}
function onWindowResize() {

  camera.aspect = container.clientWidth / thheight;
  camera.updateProjectionMatrix();

  renderer.setSize( container.clientWidth, thheight);

}
function pad(n, width, z) {
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}
function onDocumentMouseDown( event ) {

  event.preventDefault();

  isUserInteracting = true;

  onPointerDownPointerX = event.clientX;
  onPointerDownPointerY = event.clientY;
  console.log(event);
  onPointerDownLon = lon;
  onPointerDownLat = lat;
  //vector from camera to mouse
  var vectorMouse = new THREE.Vector2( );
  vectorMouse.x=(event.offsetX/container.clientWidth)*2-1;
  vectorMouse.y=1-(event.offsetY/thheight)*2;

  var raycaster = new THREE.Raycaster();
  // update the picking ray with the camera and mouse position
  raycaster.setFromCamera( vectorMouse, camera );

  // calculate objects intersecting the picking ray
  intersects = raycaster.intersectObjects( [plane, plane2],true );
  console.log("inter:"+intersects.length);
  for( var i = 0; i < intersects.length; i++ ) {
    var intersection = intersects[ i ];
    obj = intersection.object;
    console.log("intersect");
    current = parseInt(current);
    if (obj === plane ){
      current = current -1;
      if (current < 0 ) current = 0;
    }else{
      current = current +1;
    }
    //var tmp_file =material_file.substr(0 ,material_file.length-8)+pad(current,4)+".jpg";
    //set_material(tmp_file);
    var feature = gotoFeature(current_tramo,current);
    if (feature){
      update_panorma(feature);
    }

    //var desc_tramo = getTramoInfoByCoords();
    //$("#panorama_title").html(desc_tramo);
    //rotate_sphere(offsets.rot, offsets.lat, offsets.lon);
    //obj.material.color.setRGB( 1.0 - i / intersects.length, 0, 0 );
  }
}

function onDocumentMouseMove( event ) {

  if ( isUserInteracting === true ) {

    lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
    lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;

  }else{
    //vector from camera to mouse
    var vectorMouse = new THREE.Vector2( );
    vectorMouse.x=(event.offsetX/container.clientWidth)*2-1;
    vectorMouse.y=1-(event.offsetY/thheight)*2;

    var raycaster = new THREE.Raycaster();
    // update the picking ray with the camera and mouse position
    raycaster.setFromCamera( vectorMouse, camera );

    // calculate objects intersecting the picking ray
    intersects = raycaster.intersectObjects( [plane, plane2],true );
    //console.log("inter:"+intersects.length);
    if (intersects.length > 0 ){
      //console.log("intersect");
      document.body.style.cursor = 'pointer';
    }else{
      document.body.style.cursor = '';
    }

  }

}


function onDocumentMouseUp( event ) {

  isUserInteracting = false;

}

function ontouchstart(ev){
  isUserInteracting = true;
  onPointerDownPointerX = ev.touches[0].pageX;
  onPointerDownPointerY = ev.touches[0].pageY;
  onPointerDownLon = lon;
  onPointerDownLat = lat;
}

function ontouchend(ev){
  isUserInteracting = false;
}

function ontouchmove(ev){
  if ( isUserInteracting === true ) {
    lon = ( onPointerDownPointerX - ev.touches[0].pageX) * 0.1 + onPointerDownLon;
    lat = ( ev.touches[0].pageY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
  }
}

function onDocumentMouseWheel( event ) {

  // WebKit

  if ( event.wheelDeltaY ) {

    camera.fov -= event.wheelDeltaY * 0.05;

    // Opera / Explorer 9

  } else if ( event.wheelDelta ) {

    camera.fov -= event.wheelDelta * 0.05;

    // Firefox

  } else if ( event.detail ) {

    camera.fov += event.detail * 1.0;

  }

  camera.updateProjectionMatrix();

}

function animate() {

  requestAnimationFrame( animate );
  update();

}

function update() {

  //if ( isUserInteracting === false ) {

  //lon += 0.1;

  //}

  lat = Math.max( - 85, Math.min( 85, lat ) );
  phi = THREE.Math.degToRad( 90 - lat );
  theta = THREE.Math.degToRad( lon );

  camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
  camera.target.y = 500 * Math.cos( phi );
  camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );

  camera.lookAt( camera.target );

  /*
				// distortion
				camera.position.copy( camera.target ).negate();
				*/

  renderer.render( scene, camera );

}
